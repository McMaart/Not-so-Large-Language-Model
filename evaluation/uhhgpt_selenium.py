"""
Selenium script for the automatic evaluation of the stories generated from our models with UHHGPT (GPT-4o).
For this script to work, the user must fulfill the following requirements:
1. The user must have the Chrome browser installed and must download a suitable version of the Chromedriver
(see https://googlechromelabs.github.io/chrome-for-testing/). To ensure that the file is found, the location of the
'chromedriver.exe' file should be included in the PATH environment variable.
2. The user must create an environment variable with the variable name "PASS_UNI". The value of this variable is
the (seven-character) name of the user account for the UHH (e.g., 'BAO1234'), followed by the corresponding password.
Example of the value of the environment variable (for the user account 'BAO1234' with the password 'Password420'):
BAO1234Password420
"""
import sys
import time
from os import environ
from selenium.common import NoSuchElementException
from selenium.webdriver import Keys, Chrome
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.by import By
from prompt_testing.parse_model_reply import parse_prompt_0


class ChromeDriver(Chrome):
    """
    Custom wrapper around the Selenium Chrome webdriver.
    """

    def __init__(self, wait: int = 10):
        """
        :param wait: Time to implicitly wait for elements to be found on the page.
        """
        options = Options()
        options.add_argument("--disable-search-engine-choice-screen")
        super().__init__(options=options)
        self.maximize_window()
        self.implicitly_wait(wait)

    def click_css_element(self, selector: str):
        """
        Clicks an element on the page with the given CSS selector.
        :param selector: CSS selector to identify the element.
        """
        self.find_element(By.CSS_SELECTOR, selector).click()


def get_response(driver: ChromeDriver, wait: int | float = 3, max_iter: int = 100) -> str:
    """
    Retrieves the response generated by UHHGPT (GPT-4o).
    In order to verify that UHHGPT has finished generating the response, the function repeatedly
    checks if the response has stopped changing.
    :param driver: The ChromeDriver instance after the setup.
    :param wait: Time to wait between checking the response text.
    :param max_iter: Maximum number of iterations to check for changes in the response.
    :return: The response generated by UHHGPT.
    """
    prev_response = "NAN"
    for _ in range(max_iter):
        time.sleep(wait)

        cur_response = driver.find_element(By.CSS_SELECTOR, 'body > div > div.main > div.messages > div:nth-child(3) > '
                                                            'div > div.message-text').text
        if cur_response == prev_response:
            return cur_response
        prev_response = cur_response

    return prev_response


def webdriver_setup() -> ChromeDriver:
    """
    Setup for prompting to the UHHGPT GPT-4o model.
    The function initialzes a ChromeDriver, logs in to UHHGPT (using the credentials described at the top of this file)
    and selects the GPT-4o model.
    :return: The ChromeDriver instance after setup.
    """
    # Login
    driver = ChromeDriver()
    driver.get("https://uhhgpt.uni-hamburg.de/login.php")
    driver.click_css_element('body > div > aside > div.loginPanel > form > button')  # login button on title page
    try:
        user_elem = driver.find_element(By.CSS_SELECTOR, '#username')
    except NoSuchElementException as exc:
        print(exc, file=sys.stderr)
        sys.exit(1)

    user_elem.send_keys(environ.get('PASS_UNI')[:7])
    pass_elem = driver.find_element(By.CSS_SELECTOR, '#password')
    pass_elem.send_keys(environ.get('PASS_UNI')[7:])
    driver.click_css_element('#inhalt > main > section.spalten > article > div:nth-child(2) > div > div > '
                             'div.loginform > div.left > form > div.form-element-wrapper > button')  # confirm login
    driver.click_css_element('#data-protection > div > button')  # accept terms of use

    # Change to the GPT-4o-model from the menu
    driver.click_css_element('body > div > div.sidebar > div.menu > div.radiogroup > label:nth-child(2) > p')
    driver.click_css_element('body > div > div.main > div.input-container > center > button')  # start new chat
    return driver


def get_ratings(driver: ChromeDriver, instruction: str, generated_stories: list[str],
                print_response: bool = False) -> list[list[int] | None]:
    """
    Using the provided instruction prompt and generated stories, the function prompts them to UHHGPT and retrieves the
    generated ratings. For each story, an integer list is created, which consists of the ratings for the six categories
    [<GRAMMAR>, <SPELLING>, <CONSISTENCY>, <STORY>, <CREATIVITY>, <STYLE>].
    :param driver: The ChromeDriver instance after the setup.
    :param instruction: The instruction template to send to the model, which includes a '{}' formatting placeholder
    for inserting the stories.
    :param generated_stories: A list of generated stories to be evaluated.
    :param print_response: Whether to print the response from UHHGPT
    :return: A list of the rating lists for the story.
    If the response from UHHGPT cannot be parsed, None is appended instead for this story.
    """
    story_ratings = []
    for story in generated_stories:
        full_prompt = instruction.format(story)
        prompt_elem = driver.find_element(By.CSS_SELECTOR, '#texreachat')
        driver.execute_script("arguments[0].value = arguments[1];", prompt_elem, full_prompt)
        prompt_elem.send_keys(Keys.RETURN)

        answer = get_response(driver)
        story_ratings.append(parse_prompt_0(answer))

        driver.click_css_element('body > div > div.main > div.input-container > center > button')  # new chat
        if print_response is True:
            print(f"UHHGPT:\n{answer}", end="\n\n")

    return story_ratings


def save_to_file(stories: list[str], ratings: list[list[int]], model_name: str):
    """
    Writes the generated stories and ratings from the model model_name to a file.
    :param stories: The list of generated stories.
    :param ratings: The list of ratings from UHHGPT.
    :param model_name: The name of the model
    """
    s = (f"Stories generated by the model '{model_name}' with temperature 0.65.\n"
         f"The ratings are in the format [<GRAMMAR>, <SPELLING>, <CONSISTENCY>, <STORY>, <CREATIVITY>, <STYLE>]."
         f"\n\n")
    s += "\n".join(f"Story {idx}: {story}\nRating: {rating}\n"
                   for idx, (story, rating) in enumerate(zip(stories, ratings), 1))
    with open(f"../stories_and_ratings/stories_{model_name}.txt", "w") as f:
        f.write(s)


if __name__ == '__main__':
    from evaluation.prompts_gpt_eval import prompt_v2
    from io_utils import prompt_model
    import numpy as np
    np.set_printoptions(precision=4)

    model_name = "transformer_8.3M"
    num_stories = 5
    stories = [prompt_model(model_name=model_name, start_str="", temperature=0.65)
               for _ in range(num_stories)]
    print(stories)

    webdriver = webdriver_setup()
    ratings = get_ratings(webdriver, prompt_v2, stories)
    print(f"Rating list: {ratings}")

    rating_arr = np.array([rating for rating in ratings if rating is not None])
    print(f"Number of valid ratings: {len(rating_arr)} ... "
          f"{"OK" if len(rating_arr) == num_stories else "Rating not complete!"}")
    save_to_file(stories, ratings, model_name)
    print(f"Avg. rating: {rating_arr.mean(axis=0)}")
    print(f"Std:         {rating_arr.std(axis=0)}")
